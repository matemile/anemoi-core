defaults:
- data: zarr_interpolator_v6hr_1hr
- dataloader: native_grid_interpolator_v6hr_1hr
- datamodule: single
- diagnostics: evaluation
- hardware: example
- graph: multi_scale
- model: transformer
- training: interpolator
- _self_

config_validation: False # False to test the time cross entropy loss

#dataloader:
  # model_run_info: #Add for non-analysis training
  #  start: 2020-02-05T12:00:00
  #  length: 18 #in number of dates (* frequency for actual time)

hardware:
  files:
    dataset: aifs-ea-an-oper-0001-mars-o96-1979-2024-1h-v5.zarr
    dataset_land: aifs-ea-an-oper-0001-mars-o96-1979-2024-1h-v1-land.zarr
    dataset_6_accums: aifs-ea-an-oper-0001-mars-o96-1979-2024-1h-v1-accumulation6h.zarr


model:
  model:
    _target_: anemoi.models.models.interpolator.AnemoiModelEncProcDecInterpolator
  latent_skip: True # True/False for skip connection on latent mesh
  grid_skip: 0 # Which of the input indices to use as residual connection, null if none.



  # Mass-conserving accumulations
  # Ensure each predicted interpolated target sums to its accumulated forcing input.
  # The sum of predicted targets at `training.explicit_times.target` (with step `data.frequency`)
  #   should match the accumulated input at `training.explicit_times.input[-1]` e.g. the r.h.s of the accumulation input
  # Requirements:
  # - In config.data: targets must be listed under `diagnostic`; accumulation inputs under `forcing`.
  # - Use the `zero_overwriter` processor to zero the left boundary (time_index=0) of each accumulation input,
  mass_conserving_accumulations:
    tp : tp_accum
    cp : cp_accum
    ro : ro_accum
    sf : sf_accum
    ssrd : ssrd_accum
    strd : strd_accum

  # Per-variable softmax temperature (inverse temperature as scale)
  # Default scale applies to all accumulated targets unless overridden below.
  mass_conserving_softmax_default_scale: 3.0

  # Optional per-variable overrides (keys must match output variable names in mass_conserving_accumulations)
  mass_conserving_softmax_scales:
    tp: 5.5
    cp: 4.5
    ro: 2.0
    sf: 2.0
    ssrd: 1.5
    strd: 1.5

  # Sigmoid-bounded scale ranges
  # Default bounds for all accumulated targets unless overridden below.
  mass_conserving_softmax_default_min_scale: 0.5
  mass_conserving_softmax_default_max_scale: 10.0

  # Optional per-variable bounds
  # Choose tighter ranges for peaky vs flatter variables to control sharpness
  mass_conserving_softmax_scale_bounds:
    tp: {min: 2.5, max: 15.0}
    cp: {min: 2.0, max: 12.0}
    ro: {min: 1.5, max: 8.0}
    sf: {min: 1.5, max: 8.0}
    ssrd: {min: 1.0, max: 4.0}
    strd: {min: 1.0, max: 4.0}

  bounding: #These are applied in order
    # Bound tp (total precipitation) with a Relu bounding layer
    # ensuring a range of [0, infinity) to avoid negative precipitation values.
    - _target_: anemoi.models.layers.bounding.ReluBounding #[0, infinity)
      variables:
      - tcw
      - q_50
      - q_100
      - q_150
      - q_200
      - q_250
      - q_300
      - q_400
      - q_500
      - q_600
      - q_700
      - q_850
      - q_925
      - q_1000
    - _target_: anemoi.models.layers.bounding.HardtanhBounding #[0, 1)
      variables:
      - tcc
      - swvl1
      - swvl2
      min_val: 0
      max_val: 1
    - _target_: anemoi.models.layers.bounding.FractionBounding # fraction of tp
      variables:
      - lcc
      - mcc
      - hcc
      min_val: 0
      max_val: 1
      total_var: tcc

training:
  
  temporal_distribution_loss_weight: 1.0
  
  validation_metrics:
    # loss class to initialise
    mse:
      _target_: anemoi.training.losses.MSELoss
      # Scalers to include in loss calculation
      # Cannot scale over the variable dimension due to possible remappings.
      # Available scalers include:
      # - 'loss_weights_mask': Giving imputed NaNs a zero weight in the loss function
      # Use the `scale_validation_metrics` section to variable scale.
      scalers: []
      # other kwargs
      ignore_nans: True
    
    mae:
      _target_: anemoi.training.losses.MAELoss
      # Scalers to include in loss calculation
      # Cannot scale over the variable dimension due to possible remappings.
      # Available scalers include:
      # - 'loss_weights_mask': Giving imputed NaNs a zero weight in the loss function
      # Use the `scale_validation_metrics` section to variable scale.
      scalers: []
      # other kwargs
      ignore_nans: True


  explicit_times:
    input: [0,6]
    target: [1,2,3,4,5,6]

  target_forcing: #forcing parameters for the target time to include as input
    data: #of which come from the dataset
      - "insolation"
    time_fraction: True

  metrics:
    - all

  scalers:
    # Several scalers can be added here. In order to be applied their names must be included in the loss.
    # scaler name must be included in `scalers` in the losses for this to be applied.
    general_variable:
      _target_: anemoi.training.losses.scalers.GeneralVariableLossScaler
      weights:
        default: 1
        q: 0.6 #1
        t: 3   #1
        u: 0.8 #0.5
        v: 0.5 #0.33
        w: 0.001
        z: 6  #1
        sp: 1
        10u: 0.1
        10v: 0.1
        100u: 0.1
        100v: 0.1
        2d: 0.5
        tp: 0.025
        cp: 0.0025
        ro: 0.0025
        sf: 0.025
        tcc: 0.1
        mcc: 0.1
        lcc: 0.1
        hcc: 0.1
        swvl2: 2
        swvl1: 1
        stl2: 2
        stl1: 2
        ssrd: 0.05
        strd: 0.1
      
    # Additional variable scaler specifically for accumulated variables used by the interpolator
    # Adjust per-variable weights here as needed for accumulated targets
    accumulated_variable:
      _target_: anemoi.training.losses.scalers.GeneralVariableLossScaler
      weights:
        default: 1.0
        tp: 0.025
        cp: 0.0025
        sf: 0.025
        ro: 0.0025
        sstrd: 0.05
        ssrd: 0.1


    pressure_level:
      _target_: anemoi.training.losses.scalers.ReluVariableLevelScaler
      group: pl
      y_intercept: 0.2
      slope: 0.001

    # mask NaNs with zeros in the loss function
    nan_mask_weights:
      _target_: anemoi.training.losses.scalers.NaNMaskScaler

    # tendency scalers
    # scale the prognostic losses by the stdev of the variable tendencies (e.g. the 6-hourly differences of the data)
    # useful if including slow vs fast evolving variables in the training (e.g. Land/Ocean vs Atmosphere)
    # if using this option 'variable_loss_scalings' should all be set close to 1.0 for prognostic variables
    stdev_tendency:
      _target_: anemoi.training.losses.scalers.StdevTendencyScaler

    var_tendency:
      _target_: anemoi.training.losses.scalers.VarTendencyScaler

    # Scalers from node attributes
    node_weights:
      _target_: anemoi.training.losses.scalers.GraphNodeAttributeScaler
      nodes_name: ${graph.data}
      nodes_attribute_name: area_weight
      norm: unit-sum

diagnostics:
  log:
    mlflow:
      max_params_length: 3000
      tracking_uri: null
    wandb:
      entity: null

  plot: # Callbacks are currently not supported for interpolator
    callbacks: []
    colormaps: {}
